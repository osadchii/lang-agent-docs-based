# To‑Do: Пошаговый план имплементации

Назначение: последовательный план работ для вывода минимально жизнеспособного продукта (бот отвечает на вопросы) с ранним CI/CD и деплоем. Все задачи выполняются в строгом соответствии с документацией в `docs/` (источник правды). Любые отклонения — обновить код и соответствующие документы в одном PR.

## Definition of Done (для каждого шага)
- Обновлены релевантные документы в `docs/`
- Качество кода: `black`, `isort`, `ruff`, `mypy` без ошибок
- Тесты проходят, покрытие backend ≥85% (критичные модули — 100%)
- Pipeline CI зелёный; при необходимости обновлён деплой
- Нет секретов в репозитории; конфиги через `.env` и `Settings`
- При закрытии каждой задачи обязательно отмечаем чекбокс в этом списке.

## Этап A. Инициализация проекта (Backend + общая структура)
- [x] **1) Скелет репозитория**
   - Создать структуру: `backend/app/{api,core,services,models,repositories}`; `backend/tests/`
   - Добавить `backend/pyproject.toml` (ruff, black, isort, mypy), `backend/requirements.txt`, `.editorconfig`, `.gitignore`, `.env.example`
   - Настроить `app.core.config.Settings` (строгая типизация, чтение `.env`)
   - Acceptance: локальный импорт/запуск без ошибок

- [x] **2) FastAPI приложение и health endpoint**
   - `app/main.py` с FastAPI, роут `/health` (см. `docs/backend-api.md` → Health Check)
   - Подготовить CORS (строго: `https://webapp.telegram.org` + домен продакшена из ENV)
   - Acceptance: `uvicorn app.main:app --reload` и `GET /health` → 200 JSON (без внешних проверок пока)

- [x] **3) Логирование (структурированное)**
   - `app/core/logging.py`: JSON‑логи, уровень из ENV, кореляционный `request_id`
   - Встроить middleware для `request_id` и access‑логов
   - Acceptance: логи в stdout в JSON, поля: level, ts, method, path, status, request_id

- [x] **4) База данных и миграции**
   - PostgreSQL (SQLAlchemy 2.x, async) + Alembic
   - Сразу добавить модели и миграции для: `users`, `conversation_history` (см. `docs/backend-database.md`)
   - Сервис и репозитории: `UserRepository`, `ConversationRepository`
   - Acceptance: `alembic upgrade head` применяет миграции, базовые CRUD тесты зелёные

- [x] **5) Локальное окружение**
   - `docker-compose.local.yml`: `postgres`, `redis` (см. `docs/deployment.md`), сети/тома
   - Makefile или `scripts/` с командами: `local-up`, `local-down`, `test`, `lint`
   - Acceptance: `docker-compose -f docker-compose.local.yml up -d` поднимает сервисы; backend коннектится к БД

- [x] **6) Базовые тесты и quality gates**
   - Pytest конфиг, smoke‑тест `/health`, репозитории (users, conversation)
   - Настроить `pytest --cov=app --cov-fail-under=85`
   - Acceptance: локальный запуск тестов зелёный, покрытие ≥85%

## Этап B. CI/CD и деплой (сразу после скелета)
- [x] **7) CI: backend tests**
   - Настроить job `tests` в `.github/workflows/backend-deploy.yml` (см. `docs/ci-cd.md`), сервисы Postgres/Redis в job
   - Шаги: линтеры, типы, тесты, coverage upload (опц.)
   - Acceptance: pipeline успешно проходит на любом пуше в ветки

- [x] **8) Образы и прод‑compose**
   - `backend/Dockerfile` (см. `docs/deployment.md`), корневой `docker-compose.yml` для prod
   - Healthcheck контейнера и зависимостей; команда старта с Alembic upgrade перед `uvicorn`
   - Acceptance: локальная сборка образа, `docker-compose up -d backend db redis` работает

- [x] **9) CI: backend deploy (main)**
   - `.github/workflows/backend-deploy.yml`: buildx, push в GHCR (осадчий/lang-agent-docs-based), проверка сборки на PR
   - Обновить чек-лист GitHub Secrets (GHCR_USERNAME, GHCR_TOKEN) и инструкции по ручному деплою
   - Acceptance: пуш в `main` публикует образ, сервер обновляется командой `docker compose pull backend && docker compose up -d`

## Этап C. Обсервабилити (локально и/или прод)


- [x] **10) Loki + Grafana (локально и опционально на проде)**
   - Продовый `docker-compose.yml` расширен сервисами `loki`, `promtail`, `grafana`; промтейл читает docker‑логи backend и пушит их в Loki.
   - Конфиги лежат в `infra/{loki,promtail,grafana}/` и провиженят datasource + дашборд (RPS, p95 latency, ошибки, 4xx/5xx, top endpoints).
   - README + `docs/deployment.md` объясняют копирование `infra/`, настройки Grafana и порядок запуска.
   - Acceptance: backend‑логи попадают в Loki, Grafana показывает готовый дашборд.

- [x] **11) Метрики и трассировки (минимум)**
   - Добавить Prometheus‑совместимые метрики через `prometheus_fastapi_instrumentator`
   - Привязка `request_id` к логам/ошибкам; базовые алерты (если Grafana/Prometheus есть на проде)
   - Acceptance: `/metrics` доступен локально; при включении на проде — графики в Grafana

## Этап D. Безопасность и конфигурация
- [x] **12) Settings и секреты**
   - Полный список переменных окружения (см. `docs/deployment.md`), `.env.example` с комментариями
   - JWT параметры, CORS, токены провайдеров, Redis URL, DB URL
   - Acceptance: приложение не стартует без обязательных переменных (чёткие ошибки)

- [x] **13) CORS и заголовки**
   - Разрешить только `https://webapp.telegram.org` и прод‑домен; для локального фронтенда — whitelisting `http://localhost:*` через ENV
   - Добавить security middleware (HSTS в Nginx), ограничить размер запросов
   - Acceptance: preflight проходит только для допустимых origin

- [x] **14) Единый формат ошибок и обработчики**
  - Глобальные exception handlers FastAPI (валидация, 404/409, бизнес‑ошибки, внешние сервисы)
  - Единый контракт ошибок как в `docs/backend-api.md` → «Обработка ошибок» (коды, payload)
  - Acceptance: все ошибки API возвращаются в стандартизированном формате; тесты на маппинг исключений

## Этап E. Интеграция с Telegram Bot (базовый диалог)
- [ ] **15) Бот и вебхук**
   - Библиотека `python-telegram-bot` 20+; эндпоинт `POST /telegram-webhook/{bot_token}` в FastAPI (см. `docs/architecture.md`, `docs/backend-telegram.md`)
   - Старт: setWebhook (prod) / polling (dev); обработчик `/start`
   - Acceptance: сообщение в бота достигает backend handler (логи, 200), бот отвечает "Привет!"

- [ ] **16) Пользователь и онбординг**
   - На первое сообщение: `get_or_create_user(telegram_id, ...)` в БД (таблица `users`)
   - Логика онбординга: зафиксировать минимум (язык интерфейса из Telegram)
   - Acceptance: запись пользователя создаётся, повторный вход — обновление `last_activity`

- [ ] **17) Диалог с LLM (минимум)**
   - Сервис `LLMService` (OpenAI SDK) + `DialogService`
   - System prompt из `docs/backend-llm.md` (минимальная версия), безопасные таймауты
   - ВАЖНО: сохранять каждое сообщение (user/assistant) в `conversation_history` сразу (никакого in‑memory)
   - Acceptance: бот отвечает на текстовые вопросы, история пишется в БД

- [ ] **18) Форматирование ответов и быстрые действия**
  - Рендер Markdown/ограничения Telegram; короткие структурированные ответы (см. `docs/backend-bot-responses.md`)
  - Inline‑кнопки: «Добавить в карточки», «Открыть Mini App», пагинация длинных списков; callback‑обработчики
  - Acceptance: сообщения бота аккуратно форматируются, работают базовые inline‑кнопки и callbacks

## Этап F. LLM провайдер и промпты
- [ ] **19) Адаптер LLM**
   - Обёртка над OpenAI: инициализация клиента, retries, таймауты, логирование токенов
   - Конфиг модели/температуры из ENV; фича‑флаг альтернативного провайдера (на будущее)
   - Acceptance: юнит‑тесты адаптера (моки), стабильная обработка ошибок API

- [ ] **20) Промпты и контекст**
   - Структура `backend/prompts/` как в `docs/backend-llm.md`; базовый `system/teacher.txt`
   - Контекст: последние N сообщений пользователя (из БД) для ответа
   - Acceptance: ответы учитывают историю, промпт рендерится корректно

- [ ] **21) Structured output, tools и кэш**
  - Парсинг структурированных ответов через Pydantic (JSON mode), функции для специфических действий (add_card, suggest_topics)
  - Кэширование LLM‑результатов в Redis (ключи/TTL по `docs/backend-llm.md`), учёт токенов
  - Acceptance: корректный парсинг JSON‑ответов, хиты кэша видны в логах, юнит‑тесты на парсер/кэш

## Этап G. Mini App (Frontend) — ранний скелет
- [ ] **22) Бутстрап фронтенда**
   - Vite + React + TS, SDK `@twa-dev/sdk`; страницы: Home (плейсхолдер), Error
   - Интеграция Telegram WebApp initData (получение на старте)
   - Acceptance: билд/дев‑сервер, отрисовывается стартовый экран

- [ ] **23) Auth через initData**
   - Эндпоинт `/api/auth/validate` (см. `docs/backend-api.md`, `docs/backend-auth.md`) — валидация HMAC, выдача JWT
   - Frontend сохраняет JWT (memory) и использует в запросах (Axios interceptors)
   - Acceptance: успешная валидация initData, получение `user`, `token`

- [ ] **24) Минимальный экран «Задать вопрос»**
   - Простая форма: ввод текста → `POST /api/sessions/chat` (или `/api/dialog/ask`) на backend, который использует тот же `DialogService`
   - Список последних сообщений (из `/api/dialog/history`), пагинация простая
   - Acceptance: пользователь видит ответ ИИ прямо в Mini App; история приходит из БД

- [ ] **25) CI фронтенда и деплой**
   - Workflows: `frontend-test.yml`, `frontend-deploy.yml` (см. `docs/ci-cd.md`)
   - Prod hosting: выкладка `frontend/dist/` на сервер, Nginx конфиг (см. `docs/deployment.md`)
   - Acceptance: пуш в `main` деплоит фронтенд; страница грузится с сервера

## Этап H. Расширение базовой функциональности (после MVP)
- [ ] **26) Профили (минимум)**
   - Таблицы/эндпоинты `language_profiles` (см. `docs/backend-database.md`, `docs/backend-api.md`)
   - В Mini App: создать/активировать профиль, переключение в боте
   - Acceptance: 1 активный профиль/пользователь, валидации уровня CEFR

- [ ] **27) Карточки (минимум)**
   - Таблицы/эндпоинты `decks`, `cards`, `card_reviews` (минимальный SRS)
   - В боте: команды `/card`, `/decks` (простые кнопки); в App — список колод и добавление карточки
   - Acceptance: создание карточки сохраняется в БД; выбор следующей карточки отдаёт корректный объект

- [ ] **28) Упражнения (минимум)**
   - Таблицы/эндпоинты `topics`, `exercise_history`; генерация задания через LLM по активной теме
   - В App: запуск сессии 5–10 заданий, фиксация результата
   - Acceptance: выполненные упражнения пишутся в `exercise_history`, отображается базовая статистика темы

- [ ] **29) История и статистика**
   - Агрегаты по карточкам/упр.; простые метрики в App
   - Acceptance: страницы статистики отдают корректные данные, дашборды понятны

- [ ] **30) Уведомления и напоминания (стрик)**
  - Сущности `notifications`, `streak_reminders`; сервис уведомлений, базовые шаблоны
  - Планировщик рассылки напоминаний о стрике (через APScheduler/cron) и отправка через бота
  - Acceptance: пользователи получают напоминания, список уведомлений доступен в Mini App

## Этап I. Расширенные фичи (лимиты, группы, админ)
- [ ] **31) Лимиты и тарифы (скелет)**
   - Rate limiting (per‑user/глобальные) через Redis, заголовки `X-RateLimit-*` (см. `docs/backend-api.md`)
   - Планировщик сброса суточных счетчиков
   - Acceptance: превышение лимитов возвращает стандартизированную ошибку, заголовки корректны

- [ ] **32) Группы**
   - Сущности групп, шаринг колод/тем, роли владелец/участник
   - Правила доступа в API/боте, базовые экраны в App
  - Acceptance: создание группы, приглашение, доступ к общим материалам

- [ ] **33) Admin (минимум)**
  - Эндпоинты `GET /api/admin/users`, `GET /api/admin/metrics`, `POST /api/admin/users/{id}/premium`
  - Экран админа (или за фича‑флагом) в Mini App для чтения метрик; ручная выдача премиума
  - Acceptance: админ может просматривать активность и помечать пользователя как премиум

## Этап J. Медиа и мультимодальность (после базовой ветки)
- [ ] **35) Голосовые сообщения (STT)**
  - Обработка voice в боте, конвертация и Whisper STT; транскрипт → диалог/карточки
  - Лимиты размера, таймауты, сохранение транскрипта в `conversation_history`
  - Acceptance: голос → текст, бот корректно отвечает; транскрипт сохранён

- [ ] **36) Изображения и OCR**
  - Обработка изображений (фото, сканы), OCR через GPT‑4 Vision; предложение добавить слова в карточки
  - Acceptance: при отправке фото извлекается текст, предлагается добавить слова/фразы

## Этап K. Учёт токенов и оптимизации LLM
- [ ] **37) Учёт токенов и аналитика**
  - Таблица `token_usage`, запись входящих/исходящих токенов, стоимость; корреляция с `user_id/profile_id`
  - Графики в Grafana/админке; алерты при аномалиях
  - Acceptance: записи `token_usage` создаются, метрики видны

- [ ] **38) Модерация и безопасность контента**
  - OpenAI Moderation API + простые правила; graceful degradation и подсказки пользователю (см. `docs/backend-bot-responses.md`)
  - Acceptance: токсичные/неуместные запросы отсекаются, пользователь получает корректные подсказки

- [ ] **39) Резервные копии и восстановление**
  - Скрипты backup БД и retention (см. `docs/deployment.md`, `docs/backend-database.md`), документированная процедура восстановления
  - Acceptance: тестовый backup/restore успешно проходит; cron настроен на сервере

## Этап L. Mini App — полная реализация
- [ ] **40) Дизайн‑система и тема**
  - Токены: цвета, размеры, тени; компоненты: Button, Card, Input/Textarea, Modal/BottomSheet, Badge, Progress, Tabs, Toast, Skeleton, EmptyState (см. `docs/frontend-structure.md`)
  - Интеграция темы Telegram WebApp (светлая/тёмная), адаптивные шрифты и отступы
  - Acceptance: библиотека UI компонентов покрывает основные экраны; переключение темы работает

- [ ] **41) Навигация и лэйауты**
  - Routing, BottomNav, Header, TabBar; RootLayout/PracticeLayout/OnboardingLayout; guards для маршрутов
  - Поддержка Telegram BackButton/MainButton/Haptics (см. `docs/backend-telegram.md` и `docs/frontend-structure.md`)
  - Acceptance: переходы между разделами стабильны, BackButton синхронизирован с историей

- [ ] **42) API‑клиент и состояние**
  - Axios с интерсепторами (JWT + refresh при необходимости), React Query, типы API (TS)
  - ErrorBoundary, глобальные заглушки загрузки/ошибок, стратегия кэширования и инвалидации
  - Acceptance: все запросы централизованно конфигурируются, стандартные ошибки отображаются единообразно

- [ ] **43) Онбординг (UC‑0)**
  - Экраны: приветствие, выбор языка изучения, текущий/целевой уровень, цели, язык интерфейса
  - Создание/активация профиля через API; idempotent поведение при повторном входе
  - Acceptance: новый пользователь проходит онбординг и получает активный профиль

- [ ] **44) Главный экран (Home)**
  - Header, активный профиль, быстрые действия, прогресс за сегодня, недавняя активность
  - Acceptance: данные корректно отображаются и обновляются при возвращении в приложение

- [ ] **45) Карточки — полный цикл**
  - Экраны 4.1–4.7 (учить/колоды/детали/статистика/добавление/режим изучения), кнопки рейтинга, выбор следующей карточки
  - Интеграция с бэкендом (`decks`, `cards`, `card_reviews`), быстрые действия из бота (deep links)
  - Acceptance: пользователь может добавлять, учить и просматривать карточки; прогресс пишется и отображается

- [ ] **46) Упражнения — полный цикл**
  - Экраны 5.1–5.8: список/темы/детали/сессия/подсказка/завершение; free‑text и multiple‑choice
  - Интеграция с API генерации/проверки; отображение обратной связи
  - Acceptance: запуск сессии, подсказки и результаты работают, история видна

- [ ] **47) Группы**
  - Экраны 6.1–6.6: мои/участник, создание, детали (участники/материалы), приглашения, прогресс участников
  - Acceptance: пользователь создаёт/вступает/просматривает материалы и прогресс согласно ролям

- [ ] **48) Статистика**
  - Экран 7: стрик, метрики, календарь активности, графики
  - Acceptance: метрики соответствуют данным БД, календарь корректно подсвечивает активность

- [ ] **49) Профиль пользователя**
  - Информация, премиум‑бейдж (фича‑флаг), языковые профили (создать/активировать), меню
  - Acceptance: управление профилями доступно и синхронизировано с ботом

- [ ] **50) Настройки**
  - Разделы «Обучение», «Интерфейс», «Уведомления», «Данные», «Аккаунт»
  - Acceptance: настройки применяются мгновенно и сохраняются при перезапуске приложения

- [ ] **51) Уведомления (ин‑апп)**
  - Список, «прочитать», «прочитать всё», бейджи непрочитанного
  - Acceptance: события из бекенда появляются в списке; бэджи синхронизируются

- [ ] **52) Deep Links и взаимодействие с ботом**
  - Открытие экранов: карточки/упражнения/группы/подписка/уведомления; возврат в бот
  - Acceptance: deeplink корректно открывает нужный экран/сущность; возврат работает

- [ ] **53) Производительность и UX‑полировка**
  - Code splitting, prefetch, оптимизация изображений, skeleton‑состояния, плавные переходы
  - Haptic feedback и MainButton для ключевых действий
  - Acceptance: TTI/интерактивность в норме, ощущение «нативности» Telegram

- [ ] **54) E2E‑тесты Mini App**
  - Playwright/Cypress: smoke + критические пути (онбординг, карточки, упражнения)
  - Интеграция в CI (workflow `frontend-test.yml`), артефакты скриншотов
  - Acceptance: тесты стабильны и зелёные в CI

- [ ] **55) Локализация и доступность**
  - i18n (ru как минимум), контрастность, фокус‑стили, размеры touch‑таргетов
  - Acceptance: строки выведены в словари, навигация с клавиатуры адекватна

- [ ] **56) Экраны ошибок/офлайна**
  - Error, No Internet, Update Required; graceful degradation
  - Acceptance: корректное отображение и восстановление после ошибок

- [ ] **57) Хранилище и персист состояния**
  - Session/Local Storage стратегии, Telegram CloudStorage (пригодно) для лёгких данных
  - Acceptance: важные состояния переживают перезапуск, не конфликтуют между сессиями

- [ ] **58) Телеметрия UI (опционально)**
  - Минимальные события: экраны, ошибки, критические действия; respect privacy
  - Acceptance: события видны в консоли/логах, отключаемы флагом

## Этап M. Монетизация (самый последний)
- [ ] **59) Экран Premium и управление подпиской (вместе с 60)**
  - Экран оформления Premium, страница управления подпиской; статусы/ошибки платежей
  - Acceptance: UI полностью соответствует состояниям бекенда подписок; до этапа 60 показывать «все лимиты — как у премиум»

- [ ] **60) Подписки (Stripe)**
  - Схема `subscriptions`, обработка webhooks (`checkout.session.completed`, `invoice.paid`, и т.п.)
  - Эндпоинты для создания checkout‑сессии, отображение статуса в App
  - Acceptance: успешный платёж меняет статус подписки; флаги в JWT отражают премиум

## Нефункциональные требования и оговорки
- Хранение данных «сразу правильно»: история диалогов, карточки, упражнения — только в БД, не in‑memory
- Слой сервисов не зависит от фреймворка; обработчики (бот/REST) только валидируют и делегируют в сервисы
- Производительность: таймауты LLM, очереди/ретраи; кэш Redis для горячих данных (позже)
- Безопасность: не доверяем `user_id` из клиента; для Mini App — только `initData` с HMAC
- Документация — закон: при изменениях обновлять `docs/*` в том же PR

## Ранние демонстрации (контрольные точки)
- A2: локальный `/health` 200, миграции применяются
- B9: автодеплой из `main`, `/health` 200 на прод‑сервере
- E17: бот отвечает на вопросы, история в БД
- G24: Mini App задаёт вопрос и получает ответ, история из БД

## Следующие шаги прямо сейчас
1) Этап B (7–9): настроить CI/CD, образы и автодеплой; проверить `/health` на сервере
2) Этап D (12–14): довести настройки, CORS и единый формат ошибок
3) Этап E/F (15–21): подключить бота, онбординг и минимальный текстовый диалог + LLM‑адаптер/промпты/кэш
4) Этап G (22–25): запустить Mini App с авторизацией через initData и экраном «Задать вопрос»
5) Этап H (26–30): добавить профили, минимальные карточки/упражнения и статистику + уведомления о стрике

Примечание: до имплементации подписок (этап 60) все пользователи считаются премиум по лимитам. После включения Stripe — перевести логику на реальные тарифы.
